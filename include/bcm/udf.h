/*
 * 
 * This software is governed by the Broadcom Switch APIs license.
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenNSA/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_UDF_H__
#define __BCM_UDF_H__

#include <bcm/types.h>
#include <bcm/field.h>

/* Options to control UDF allocation */
#define BCM_UDF_CREATE_O_NONE           (0)        /* Default. */
#define BCM_UDF_CREATE_O_WITHID         (1 << 0)   /* Use input UDF ID instead
                                                      of allocating one. */
#define BCM_UDF_CREATE_O_REPLACE        (1 << 1)   /* Replace/Update existing
                                                      UDF object. */
#define BCM_UDF_CREATE_O_FLEXHASH       (1 << 2)   /* UDF allocation will be
                                                      adjusted for use by flex
                                                      hashing feature. */
#define BCM_UDF_CREATE_O_FIELD_INGRESS  (1 << 3)   /* UDF allocation will be
                                                      adjusted for use by
                                                      Ingress stage FP. */
#define BCM_UDF_CREATE_O_FIELD_LOOKUP   (1 << 4)   /* UDF allocation will be
                                                      adjusted for use by Lookup
                                                      stage FP. */
#define BCM_UDF_CREATE_O_SHARED_HWID    (1 << 5)   /* Use same hardware
                                                      resources as 'shared_udf' */
#define BCM_UDF_CREATE_O_POLICER_GROUP  (1 << 6)   /* UDF allocation will be
                                                      adjusted for use by global
                                                      (service) meter. */
#define BCM_UDF_CREATE_O_UDFHASH        (1 << 7)   /* UDF allocation will be
                                                      adjusted for use by udf
                                                      hashing feature. */
#define BCM_UDF_CREATE_O_RANGE_CHECK    (1 << 8)   /* UDF allocation will be
                                                      adjusted for use by Range
                                                      checker. */
#define BCM_UDF_CREATE_O_FLEX_COUNTER   (1 << 9)   /* UDF allocation will be
                                                      adjusted for use by
                                                      Flexible Counter. */

/* UDF Packet Format Options */
#define BCM_UDF_PKT_FORMAT_CREATE_O_NONE    0          /* Default. */
#define BCM_UDF_PKT_FORMAT_CREATE_O_WITHID  (1 << 0)   /* Create packet format
                                                          with given ID */
#define BCM_UDF_PKT_FORMAT_CREATE_O_REPLACE (1 << 1)   /* Update existing packet
                                                          format */

/* Packet format options */
typedef uint32 bcm_udf_pkt_format_options_t;

/* Flags to be used with bcm_udf_t.flags */
#define BCM_UDF_F_ADJUST_IP4_OPTIONS    (1 << 1)   /* Adjust offset accounting
                                                      IP4 options */
#define BCM_UDF_F_ADJUST_IP6_OPTIONS    (1 << 2)   /* Adjust offset accounting
                                                      IP6 Extension Headers */

/* Base header the switch can parse. */
typedef enum bcm_udf_layer_e {
    bcmUdfLayerL2Header = 1,        /* Start of L2 header in the Packet */
    bcmUdfLayerL3OuterHeader = 2,   /* Start of outer L3 header in the packet */
    bcmUdfLayerL3InnerHeader = 3,   /* Start of inner L3 header in the packet */
    bcmUdfLayerL4OuterHeader = 4,   /* Start of outer L4 header in the packet */
    bcmUdfLayerL4InnerHeader = 5,   /* Start of outer L4 header in the packet */
    bcmUdfLayerHigigHeader = 6,     /* Start of HiGig header in the packet */
    bcmUdfLayerHigig2Header = 7,    /* Start of HiGig2 header in the packet */
    bcmUdfLayerTunnelHeader = 8,    /* Start of outermost tunnel header in the
                                       Packet */
    bcmUdfLayerTunnelPayload = 9,   /* Start of outermost tunnel payload in the
                                       Packet */
    bcmUdfLayerUserPayload = 10,    /* Start of application payload in the
                                       Packet. */
    bcmUdfLayerCount                /* Unused. Always last in the list */
} bcm_udf_layer_t;

#define BCM_UDF_LAYER \
{ \
    "L2Header", \
    "L3OuterHeader", \
    "L3InnerHeader", \
    "L4OuterHeader", \
    "L4InnerHeader", \
    "HigigHeader", \
    "Higig2Header", \
    "TunnelHeader", \
    "TunnelPayload", \
    "UserPayload"  \
}

/* UDF structure. */
typedef struct bcm_udf_s {
    uint32 flags;           /* See BCM_UDF_F_XXX */
    bcm_udf_layer_t layer;  /* UDF base offset. bcmUdfLayerXxx */
    int start;              /* Relative offset in bits (from the 'layer') in the
                               packet */
    uint32 width;           /* width of data in bits to extract */
    bcm_pbmp_t ports;       /* ports (must belong to a single pipe) associate
                               with the udf_offset: used only in PipeLocal
                               operation supported devices */
} bcm_udf_t;

/* UDF allocation hints. */
typedef struct bcm_udf_alloc_hints_s {
    uint32 flags;               /* See BCM_UDF_CREATE_O_xxx */
    bcm_udf_id_t shared_udf;    /* Used when BCM_UDF_CREATE_O_SHARED_HWID is set */
    bcm_field_qset_t qset;      /* Field group qset for optimal H/W resource
                                   allocation */
} bcm_udf_alloc_hints_t;

/* Packet format based UDF specification structure. */
typedef struct bcm_udf_pkt_format_info_s {
    int prio;                           /* Priority of the UDF */
    bcm_ethertype_t ethertype;          /* EtherType in the packet */
    bcm_ethertype_t ethertype_mask;     /* EtherType Mask */
    uint8 ip_protocol;                  /* IP protocol field in the packet */
    uint8 ip_protocol_mask;             /* IP protocol Mask */
    uint16 l2;                          /* L2 packet format.
                                           (BCM_PKT_FORMAT_L2_XXX) */
    uint16 vlan_tag;                    /* Vlan tag format.
                                           (BCM_PKT_FORMAT_VLAN_XXX) */
    uint16 outer_ip;                    /* Outer IP header type.
                                           (BCM_PKT_FORMAT_IP_XXX) */
    uint16 inner_ip;                    /* Inner IP header type.
                                           (BCM_PKT_FORMAT_IP_XXX) */
    uint16 tunnel;                      /* Tunnel type.
                                           (BCM_PKT_FORMAT_TUNNEL_XXX) */
    uint16 mpls;                        /* Mpls labels.
                                           (BCM_PKT_FORMAT_MPLS_XXX) */
    uint16 fibre_chan_outer;            /* Fibre Channel outer header type.
                                           (BCM_PKT_FORMAT_FIBRE_CHAN_XXX) */
    uint16 fibre_chan_inner;            /* Fibre Channel inner header
                                           type.(BCM_PKT_FORMAT_FIBRE_CHAN_XXX) */
    uint16 higig;                       /* HIGIG packet
                                           format.(BCM_PKT_FORMAT_HIGIG_XXX) */
    uint16 vntag;                       /* NIV packet
                                           format.(BCM_PKT_FORMAT_VNTAG_XXX) */
    uint16 etag;                        /* Extender tag packet
                                           format.(BCM_PKT_FORMAT_ETAG_XXX) */
    uint16 cntag;                       /* CNTAG packet
                                           format.(BCM_PKT_FORMAT_CNTAG_XXX) */
    uint16 icnm;                        /* ICNM packet
                                           format.(BCM_PKT_FORMAT_ICNM_XXX) */
    uint16 subport_tag;                 /* SUBPORT_TAG packet format.
                                           (BCM_PKT_FORMAT_SUBPORT_TAG_XXX) */
    int class_id;                       /* id used by the IFP Key Selection
                                           Mechanism. Range 0~255 */
    uint16 inner_protocol;              /* Inner protocol field in the packet.
                                           Inner_ip should be set to
                                           BCM_PKT_FORMAT_IP_NONE to make this
                                           take effect. IP-IN-IP type GRE should
                                           take original API sequence. */
    uint16 inner_protocol_mask;         /* Inner protocol mask. */
    uint32 l4_dst_port;                 /* TCP or UDP Destination Port number. */
    uint32 l4_dst_port_mask;            /* TCP or UDP Destination Port number
                                           mask. */
    uint8 opaque_tag_type;              /* Tag type field in the opaque tag. */
    uint8 opaque_tag_type_mask;         /* Mask for tag type field in the opaque
                                           tag. */
    uint8 int_pkt;                      /* Inband Telemetry packet indicator. */
    uint8 src_port;                     /* Logical Source Port number. */
    uint8 src_port_mask;                /* Logical Source Port number mask. */
    uint8 lb_pkt_type;                  /* Loopback Packet Type.
                                           (BCM_PKT_FORMAT_LB_TYPE_XXX) */
    uint16 first_2bytes_after_mpls_bos; /* First 2 bytes after BOS in an mpls
                                           packet. */
    uint16 first_2bytes_after_mpls_bos_mask; /* Mask for first 2 bytes after BOS in
                                           an mpls packet. */
} bcm_udf_pkt_format_info_t;

/* Maxmium bytes of UDF Hash */
#define BCM_UDF_HASH_MAX_LENGTH 4          

/* UDF hashing configuration. */
typedef struct bcm_udf_hash_config_s {
    uint32 flags;                       /* Reserved for future usage. Must be
                                           zero today. */
    bcm_udf_id_t udf_id;                /* UDF object id */
    int mask_length;                    /* Length of mask bytes. Must equal to
                                           the width of the UDF object. */
    uint8 hash_mask[BCM_UDF_HASH_MAX_LENGTH]; /* Array of mask fields. Index 0 is MSB
                                           of mask. */
} bcm_udf_hash_config_t;

/* UDF hashing engine selection. */
#define BCM_UDF_HASH_CONFIG_ENGINE_0    0x00000001 /* UDF is used by hash engine
                                                      0. */
#define BCM_UDF_HASH_CONFIG_ENGINE_1    0x00000002 /* UDF is used by hash engine
                                                      1. */

/* Options to control UDF hashing adding. */
#define BCM_UDF_HASH_ADD_O_NONE     0          /* Default, add new entry to
                                                  list. */
#define BCM_UDF_HASH_ADD_O_REPLACE  (1 << 0)   /* Modify the entry which is
                                                  already in list */

/* Initializes the UDF structure */
extern void bcm_udf_t_init(
    bcm_udf_t *udf_info);

/* Initializes the UDF alloc hints structure */
extern void bcm_udf_alloc_hints_t_init(
    bcm_udf_alloc_hints_t *udf_hints);

/* Initialize the UDF packet format structure */
extern void bcm_udf_pkt_format_info_t_init(
    bcm_udf_pkt_format_info_t *pkt_format);

/* Initialize the UDF hashing configuration structure */
extern void bcm_udf_hash_config_t_init(
    bcm_udf_hash_config_t *info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize UDF module */
extern int bcm_udf_init(
    int unit);

/* Detach UDF module */
extern int bcm_udf_detach(
    int unit);

/* Creates a UDF object */
extern int bcm_udf_create(
    int unit, 
    bcm_udf_alloc_hints_t *hints, 
    bcm_udf_t *udf_info, 
    bcm_udf_id_t *udf_id);

/* Fetches the UDF object created in the system */
extern int bcm_udf_get(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_t *udf_info);

/* Fetches all existing UDF ids */
extern int bcm_udf_get_all(
    int unit, 
    int max, 
    bcm_udf_id_t *udf_id_list, 
    int *actual);

/* Destroys the UDF object */
extern int bcm_udf_destroy(
    int unit, 
    bcm_udf_id_t udf_id);

/* Create a packet format entry */
extern int bcm_udf_pkt_format_create(
    int unit, 
    bcm_udf_pkt_format_options_t options, 
    bcm_udf_pkt_format_info_t *pkt_format, 
    bcm_udf_pkt_format_id_t *pkt_format_id);

/* Retrieve packet format info given the packet format Id */
extern int bcm_udf_pkt_format_info_get(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id, 
    bcm_udf_pkt_format_info_t *pkt_format);

/* Destroy existing packet format entry */
extern int bcm_udf_pkt_format_destroy(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id);

/* Adds packet format entry to UDF object */
extern int bcm_udf_pkt_format_add(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_pkt_format_id_t pkt_format_id);

/* Deletes packet format spec associated with the UDF */
extern int bcm_udf_pkt_format_get(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id, 
    int max, 
    bcm_udf_id_t *udf_id_list, 
    int *actual);

/* Deletes packet format spec associated with the UDF */
extern int bcm_udf_pkt_format_delete(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_pkt_format_id_t pkt_format_id);

/* Retrieves the user defined format specification configuration from UDF */
extern int bcm_udf_pkt_format_get_all(
    int unit, 
    bcm_udf_id_t udf_id, 
    int max, 
    bcm_udf_pkt_format_id_t *pkt_format_id_list, 
    int *actual);

/* Deletes all packet format specs associated with the UDF */
extern int bcm_udf_pkt_format_delete_all(
    int unit, 
    bcm_udf_id_t udf_id);

/* Add UDF id into UDF hashing list */
extern int bcm_udf_hash_config_add(
    int unit, 
    uint32 options, 
    bcm_udf_hash_config_t *config);

/* Delete UDF id from UDF hashing list */
extern int bcm_udf_hash_config_delete(
    int unit, 
    bcm_udf_hash_config_t *config);

/* Delete all UDF id from UDF hashing list */
extern int bcm_udf_hash_config_delete_all(
    int unit);

/* Get UDF hashing configuration of a certain id */
extern int bcm_udf_hash_config_get(
    int unit, 
    bcm_udf_hash_config_t *config);

/* Get all added UDF ids from list */
extern int bcm_udf_hash_config_get_all(
    int unit, 
    int max, 
    bcm_udf_hash_config_t *config_list, 
    int *actual);

#endif /* BCM_HIDE_DISPATCHABLE */

/* 
 * List of UDF operational modes supported: used only in PipeLocal
 * operation supported devices
 */
typedef enum bcm_udf_oper_mode_e {
    bcmUdfOperModeGlobal = 0,       /* UDF Operational Global Mode Value. */
    bcmUdfOperModePipeLocal = 1,    /* UDF Operational Pipe Local Mode Value. */
    bcmUdfOperModeCount = 2         /* Always last. Not a usable value. */
} bcm_udf_oper_mode_t;

#define BCM_UDF_OPER_MODE_STRINGS \
{ \
    "Global", \
    "PipeLocal"  \
}

#ifndef BCM_HIDE_DISPATCHABLE

/* Set UDF operation mode */
extern int bcm_udf_oper_mode_set(
    int unit, 
    bcm_udf_oper_mode_t mode);

/* get UDF operation mode */
extern int bcm_udf_oper_mode_get(
    int unit, 
    bcm_udf_oper_mode_t *mode);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Base header the switch can parse. */
typedef enum bcm_udf_abstract_pkt_format_e {
    bcmUdfAbstractPktFormatLlc = 0,     /* Abstract from the start of first byte
                                           of LLC Header. */
    bcmUdfAbstractPktFormatInnerLlc = 1, /* Abstract from the start of Inner
                                           header's first byte of LLC Header. */
    bcmUdfAbstractPktFormatUnknownL3 = 2, /* Abstract from the start of first byte
                                           after unknown EtherType. */
    bcmUdfAbstractPktFormatInnerUnknownL3 = 3, /* Abstract from the start of inner
                                           header's first byte after unknown
                                           EtherType. */
    bcmUdfAbstractPktFormatKnownNonIp = 4, /* Abstract from the start of first byte
                                           after Known non-ip EtherType (other
                                           than Known IPv4/6 and FCoE/Mim/MPLS
                                           tunnels). */
    bcmUdfAbstractPktFormatInnerKnownNonIp = 5, /* Abstract from the start of Inner
                                           header's first byte after Known
                                           non-ip EtherType (other than Known
                                           IPv4/6 and FCoE/Mim/MPLS tunnels). */
    bcmUdfAbstractPktFormatKnownL3Mim = 6, /* Abstract from the start of MiM
                                           Header. */
    bcmUdfAbstractPktFormatKnownL3FcoeStdEncap = 7, /* Abstract from the start of FCoE with
                                           Standard or Encapsulation Header. */
    bcmUdfAbstractPktFormatKnownL3FcoeVftIfr = 8, /* Abstract from the start of FCoE with
                                           Virtual Fabric Tag (VFT) or Inter
                                           Fabric Routing (IFR) Header. */
    bcmUdfAbstractPktFormatKnownL3MplsOneLabel = 9, /* Abstract from the start of MPLS
                                           Header with one label. */
    bcmUdfAbstractPktFormatKnownL3MplsTwoLabel = 10, /* Abstract from the start of MPLS
                                           Header with two labels. */
    bcmUdfAbstractPktFormatKnownL3MplsThreeLabel = 11, /* Abstract from the start of MPLS
                                           Header with three labels. */
    bcmUdfAbstractPktFormatKnownL3MplsFourLabel = 12, /* Abstract from the start of MPLS
                                           Header with four labels. */
    bcmUdfAbstractPktFormatKnownL3MplsMoreThanFourLabel = 13, /* Abstract from the start of MPLS
                                           Header with more than four labels. */
    bcmUdfAbstractPktFormatUnknownL4 = 14, /* Abstract from the start of first byte
                                           of unknown L4 Header. */
    bcmUdfAbstractPktFormatInnerUnknownL4 = 15, /* Abstract from the start of Inner
                                           header's first byte of unknown L4
                                           Header. */
    bcmUdfAbstractPktFormatUdpUnknownL5 = 16, /* Abstract from the start of first byte
                                           of unknown L5 after UDP Header. */
    bcmUdfAbstractPktFormatInnerUdpUnknownL5 = 17, /* Abstract from the start of Inner
                                           header's first byte of unknown L5
                                           after UDP Header. */
    bcmUdfAbstractPktFormatUdpGpeGeneve = 18, /* Abstract from the start of first byte
                                           of known L5 Geneve header after UDP. */
    bcmUdfAbstractPktFormatUdpBfd = 19, /* Abstract from the start of first byte
                                           of known L5 BFD header after UDP. */
    bcmUdfAbstractPktFormatInnerUdpBfd = 20, /* Abstract from the start of Inner
                                           header's first byte of known L5 BFD
                                           header after UDP. */
    bcmUdfAbstractPktFormatUdpVxlan = 21, /* Abstract from the start of first byte
                                           of known L5 VXLAN header after UDP. */
    bcmUdfAbstractPktFormatUdp1588 = 22, /* Abstract from the start of first byte
                                           of known L5 1588 header after UDP. */
    bcmUdfAbstractPktFormatTcpUnknownL5 = 23, /* Abstract from the start of first byte
                                           of unknown L5 header after TCP. */
    bcmUdfAbstractPktFormatInnerTcpUnknownL5 = 24, /* Abstract from the start of Inner
                                           header's first byte of unknown L5
                                           header after TCP. */
    bcmUdfAbstractPktFormatSctpUnknownL5 = 25, /* Abstract from the start of first byte
                                           of unknown L5 header after SCTP. */
    bcmUdfAbstractPktFormatInnerSctpUnknownL5 = 26, /* Abstract from the start of Inner
                                           header's first byte of unknown L5
                                           header after SCTP. */
    bcmUdfAbstractPktFormatGreWithoutKey = 27, /* Abstract from the start of first byte
                                           of L4 header for GRE packets without
                                           key flag set (C=0/1, R=0/1 and K=0). */
    bcmUdfAbstractPktFormatGreWithKey = 28, /* Abstract from the start of first byte
                                           of L4 header for GRE packets with key
                                           flag set (C=1, R=0/1 and K=1). */
    bcmUdfAbstractPktFormatGreWithoutChecksumRouting = 29, /* Abstract from the start of first byte
                                           of L4 header for GRE packets (with
                                           flags C=0, R=0 and K=1). */
    bcmUdfAbstractPktFormatL2GreWithoutChecksumRouting = 30, /* Abstract from the start of first byte
                                           of L4 header for L2-GRE packets (with
                                           flags C=0, R=0, K=1). */
    bcmUdfAbstractPktFormatL2GreWithoutRouting = 31, /* Abstract from the start of first byte
                                           of L4 header for L2-GRE packets (with
                                           flags R=0, C=1, K=1). */
    bcmUdfAbstractPktFormatAchNonIp = 32, /* Abstract from the start of ACH Header
                                           for a NonIp packet. */
    bcmUdfAbstractPktFormatUdpINT = 33, /* Abstract from the start of first byte
                                           of UDP header to match on port based
                                           INT (Inband-Telemetry) header
                                           payload. */
    bcmUdfAbstractPktFormatTcpUnknownL5WithIpExtnHdr = 34, /* Abstract from the start of first byte
                                           of TCP header for unknown L5 packet. */
    bcmUdfAbstractPktFormatL3GreUnknownPayload = 35, /* Abstract from the start of first byte
                                           of L3 GRE header for unknown GRE type
                                           packets. */
    bcmUdfAbstractPktFormatGreWithKeyRouting = 36, /* Abstract from the start of first byte
                                           of L4 header for GRE packets (with
                                           key and routing flag set K=1, R=1,
                                           C=0/1). */
    bcmUdfAbstractPktFormatL2GreWithKeyRouting = 37, /* Abstract from the start of first byte
                                           of L4 header for L2-GRE packets (with
                                           flags K=1, R=1, C=0/1). */
    bcmUdfAbstractPktFormatInnerUdp1588 = 38, /* Abstract from the start of Inner
                                           header's first byte of known L5 1588
                                           header after UDP. */
    bcmUdfAbstractPktFormatTcpINT = 39, /* Abstract from the start of first byte
                                           of TCP header to match on INT
                                           (Inband-Telemetry) header payload. */
    bcmUdfAbstractPktFormatKnownL3FcoeUnknownRctl = 40, /* Abstract from the start of FCoE with
                                           Unknown R_CTL. */
    bcmUdfAbstractPktFormatHiGigPpd0 = 41, /* Abstract from the start of HiGig
                                           System Header. */
    bcmUdfAbstractPktFormatHiGigPpd0EHType0 = 42, /* Abstract from the start of HiGig
                                           System Header. */
    bcmUdfAbstractPktFormatHiGigPpd0EHType1 = 43, /* Abstract from the start of HiGig
                                           System Header. */
    bcmUdfAbstractPktFormatHiGigPpd0EHType2 = 44, /* Abstract from the start of HiGig
                                           System Header. */
    bcmUdfAbstractPktFormatHiGigPpd2 = 45, /* Abstract from the start of HiGig
                                           System Header. */
    bcmUdfAbstractPktFormatHiGigPpd2EHType0 = 46, /* Abstract from the start of HiGig
                                           System Header. */
    bcmUdfAbstractPktFormatHiGigPpd2EHType1 = 47, /* Abstract from the start of HiGig
                                           System Header. */
    bcmUdfAbstractPktFormatHiGigPpd2EHType2 = 48, /* Abstract from the start of HiGig
                                           System Header. */
    bcmUdfAbstractPktFormatGpeIOAM = 49, /* Abstract from the start of GPE IOAM. */
    bcmUdfAbstractPktFormatKnownMplsMcast = 50, /* Abstract from the start of MPLS
                                           Multicast header. */
    bcmUdfAbstractPktFormatLoopbackHdrType0 = 51, /* Abstract from the start of Loopback
                                           Type 0 System Header. */
    bcmUdfAbstractPktFormatLoopbackHdrType1 = 52, /* Abstract from the start of Loopback
                                           Type 1 System Header. */
    bcmUdfAbstractPktFormatL3Ipv4Fragmented = 53, /* Abstract from the start of L3 for
                                           IPv4 Fragmented packets (that is,
                                           non-zero fragmented offset) without
                                           IP options. */
    bcmUdfAbstractPktFormatL3Ipv4FragmentedWithOptions = 54, /* Abstract from the start of L3 for
                                           IPv4 Fragmented packets with IP
                                           options (that is, non-zero fragmented
                                           offset). */
    bcmUdfAbstractPktFormatL3Ipv4WithoutOptions = 55, /* Abstract from the start of L3 for
                                           IPv4 packets without IP options. */
    bcmUdfAbstractPktFormatL3Ipv4WithOptions = 56, /* Abstract from the start of L3 for
                                           IPv4 packets with IP options. */
    bcmUdfAbstractPktFormatL3Ipv6 = 57, /* Abstract from the start of L3 for
                                           IPv6 packet. */
    bcmUdfAbstractPktFormatL2 = 58,     /* Abstract from the start of first byte
                                           of L2 header. */
    bcmUdfAbstractPktFormatL2Untagged = 59, /* Abstract from the start of 14 bytes
                                           after L2 header without VLAN tag. */
    bcmUdfAbstractPktFormatL2OuterVlanTag = 60, /* Abstract from the start of 14 bytes
                                           after L2 header with single outer
                                           VLAN tag. */
    bcmUdfAbstractPktFormatL2InnerVlanTag = 61, /* Abstract from the start of 14 bytes
                                           after L2 header with single inner
                                           VLAN tag. */
    bcmUdfAbstractPktFormatL2DoubleVlanTag = 62, /* Abstract from the start of 14 bytes
                                           after L2 header with double VLAN tag. */
    bcmUdfAbstractPktFormatL2GbpTag = 63, /* Abstract from the start of 14 bytes
                                           after L2 header with GBP tag (without
                                           VLAN tag). */
    bcmUdfAbstractPktFormatL2OuterVlanWithGbpTag = 64, /* Abstract from the start of 14 bytes
                                           after L2 header with single outer
                                           vlan and GBP tags. */
    bcmUdfAbstractPktFormatL2InnerVlanWithGbpTag = 65, /* Abstract from the start of 14 bytes
                                           after L2 header with single inner
                                           vlan and GBP tags. */
    bcmUdfAbstractPktFormatL2DoubleVlanWithGbpTag = 66, /* Abstract from the start of 14 bytes
                                           after L2 header with double vlan and
                                           GBP tag. */
    bcmUdfAbstractPktFormatL2Vntag = 67, /* Abstract from the start of 14 bytes
                                           after L2 header with VNTAG (without
                                           vlan tag). */
    bcmUdfAbstractPktFormatL2OuterVlanWithVntag = 68, /* Abstract from the start of 14 bytes
                                           after L2 header with single outer
                                           vlan tag and VNTAG. */
    bcmUdfAbstractPktFormatL2InnerVlanWithVntag = 69, /* Abstract from the start of 14 bytes
                                           after L2 header with single inner
                                           vlan tag and VNTAG. */
    bcmUdfAbstractPktFormatL2DoubleVlanWithVntag = 70, /* Abstract from the start of 14 bytes
                                           after L2 header with double vlan tag
                                           and VNTAG. */
    bcmUdfAbstractPktFormatL2Etag = 71, /* Abstract from the start of 14 bytes
                                           after L2 header with ETAG (without
                                           vlan tag). */
    bcmUdfAbstractPktFormatL2OuterVlanEtag = 72, /* Abstract from the start of 14 bytes
                                           after L2 header with single outer
                                           vlan tag and ETAG. */
    bcmUdfAbstractPktFormatL2InnerVlanEtag = 73, /* Abstract from the start of 14 bytes
                                           after L2 header with single inner
                                           vlan tag and ETAG. */
    bcmUdfAbstractPktFormatL2DoubleVlanEtag = 74, /* Abstract from the start of 14 bytes
                                           after L2 header with double vlan tag
                                           and ETAG. */
    bcmUdfAbstractPktFormatInnerL3Ipv4 = 75, /* Abstract from the start of Inner
                                           header's first byte of L3 IPv4
                                           header. */
    bcmUdfAbstractPktFormatInnerL3Ipv4Fragmented = 76, /* Abstract from the start of Inner
                                           header's first byte of L3 IPv4 header
                                           with non-zero fragment offset. */
    bcmUdfAbstractPktFormatInnerL3Ipv6 = 77, /* Abstract from the start of Inner L3
                                           header's first byte of L3 IPv6
                                           header. */
    bcmUdfAbstractPktFormatInnerL2Untagged = 78, /* Abstract from the start of 12 bytes
                                           after Inner L2 header with no VLAN
                                           tag. */
    bcmUdfAbstractPktFormatInnerL2OuterVlanTag = 79, /* Abstract from the start of 12 bytes
                                           after Inner L2 header with no VLAN
                                           tag. */
    bcmUdfAbstractPktFormatInnerL2InnerVlanTag = 80, /* Abstract from the start of 12 bytes
                                           after Inner L2 header with single
                                           outer VLAN tag. */
    bcmUdfAbstractPktFormatInnerL2DoubleVlanTag = 81, /* Abstract from the start of 12 bytes
                                           after Inner L2 header with single
                                           inner VLAN tag. */
    bcmUdfAbstractPktFormatInnerL2GbpTag = 82, /* Abstract from the start of 12 bytes
                                           after Inner L2 header with GBP tag
                                           (without VLAN tag). */
    bcmUdfAbstractPktFormatInnerL2OuterVlanWithGbpTag = 83, /* Abstract from the start of 12 bytes
                                           after Inner L2 header with single
                                           outer vlan and GBP tags. */
    bcmUdfAbstractPktFormatInnerL2InnerVlanWithGbpTag = 84, /* Abstract from the start of 12 bytes
                                           after Inner L2 header with single
                                           inner vlan and GBP tags. */
    bcmUdfAbstractPktFormatInnerL2DoubleVlanWithGbpTag = 85, /* Abstract from the start of 12 bytes
                                           after Inner L2 header with double
                                           vlan and GBP tags. */
    bcmUdfAbstractPktFormatUnknownL3CustomEtherType1 = 86, /* Abstract from the start of first byte
                                           of L3 with unknown custom EtherType
                                           1. */
    bcmUdfAbstractPktFormatUnknownL3CustomEtherType2 = 87, /* Abstract from the start of first byte
                                           of L3 with unknown custom EtherType
                                           2. */
    bcmUdfAbstractPktFormatUnknownL3CustomIpProtocol1 = 88, /* Abstract from the start of first byte
                                           of L4 with unknown custom IP Protocol
                                           1. */
    bcmUdfAbstractPktFormatUnknownL3CustomIpProtocol2 = 89, /* Abstract from the start of first byte
                                           of L4 with unknown custom IP Protocol
                                           2. */
    bcmUdfAbstractPktFormatUnknownL3CustomUdpDstPort1 = 90, /* Abstract from the start of first byte
                                           of L4 with unknown custom UDP
                                           destination port 1. */
    bcmUdfAbstractPktFormatUnknownL3CustomUdpDstPort2 = 91, /* Abstract from the start of first byte
                                           of L4 with unknown custom UDP
                                           destination port 2. */
    bcmUdfAbstractPktFormatInnerUnknownL3CustomEtherType1 = 92, /* Abstract from the start of first byte
                                           of Inner L3 with unknown custom
                                           EtherType 1. */
    bcmUdfAbstractPktFormatInnerUnknownL3CustomEtherType2 = 93, /* Abstract from the start of first byte
                                           of Inner L3 with unknown custom
                                           EtherType 2. */
    bcmUdfAbstractPktFormatInnerUnknownL3CustomIpProtocol1 = 94, /* Abstract from the start of first byte
                                           of Inner L4 with unknown custom IP
                                           Protocol 1. */
    bcmUdfAbstractPktFormatInnerUnknownL3CustomIpProtocol2 = 95, /* Abstract from the start of first byte
                                           of Inner L4 with unknown custom IP
                                           Protocol 2. */
    bcmUdfAbstractPktFormatInnerUnknownL3CustomUdpDstPort1 = 96, /* Abstract from the start of first byte
                                           of Inner L4 with unknown custom UDP
                                           destination port 1. */
    bcmUdfAbstractPktFormatInnerUnknownL3CustomUdpDstPort2 = 97, /* Abstract from the start of first byte
                                           of Inner L4 with unknown custom UDP
                                           destination port 2. */
    bcmUdfAbstractPktFormatUdpProbeBasedINT = 98, /* Abstract from the start of first byte
                                           of UDP header to match on probe based
                                           INT (Inband-Telemetry) header
                                           payload. */
    bcmUdfAbstractPktFormatMacsecDecrypt = 99, /* Abstract from the start of the first
                                           byte of L2 for the incoming MACSEC
                                           decrypted packet. */
    bcmUdfAbstractPktFormatGpeIOAMEdgeToEdge = 100, /* Abstract from the start of the first
                                           byte of GPE header with IOAM type as
                                           E2E (Edge to Edge). */
    bcmUdfAbstractPktFormatUdpVxlanWithoutExtnHdr = 101, /* Start of first byte of UDP Header
                                           Without Extension header. */
    bcmUdfAbstractPktFormatUdp1588WithoutExtnHdr = 102, /* Start of first byte of UDP Header
                                           Without Extension header. */
    bcmUdfAbstractPktFormatUdpBfdWithoutExtnHdr = 103, /* Start of first byte of UDP Header
                                           Without Extension header. */
    bcmUdfAbstractPktFormatUdpProbeBasedINTWithoutExtnHdr = 104, /* Abstract from the start of first byte
                                           of UDP header to match on probe based
                                           INT (Inband-Telemetry) without
                                           extension header payload */
    bcmUdfAbstractPktFormatUdpINTWithoutExtnHdr = 105, /* Start of first byte of L4 UDP header
                                           for INT (Inband-Telemetry) packet
                                           without extension header. */
    bcmUdfAbstractPktFormatInnerTcpUnknownL5WithoutExtnHdr = 106, /* To extract Unknown L5 payload fields
                                           without extension header, the base
                                           start offset should be the first byte
                                           of inner TCP Header. */
    bcmUdfAbstractPktFormatUdpUnknownL5WithoutExtnHdr = 107, /* To extract Unknown L5 payload fields,
                                           the base start offset should be the
                                           first byte of UDP Header without
                                           extension header. */
    bcmUdfAbstractPktFormatLastCount = 108 /* Unused. Always last in the list */
} bcm_udf_abstract_pkt_format_t;

#define BCM_UDF_ABSTRACT_PKT_FORMAT \
{ \
    "Llc", \
    "InnerLlc", \
    "UnknownL3", \
    "InnerUnknownL3", \
    "KnownNonIp", \
    "InnerKnownNonIp", \
    "KnownL3Mim", \
    "KnownL3FcoeStdEncap", \
    "KnownL3FcoeVftIfr", \
    "KnownL3MplsOneLabel", \
    "KnownL3MplsTwoLabel", \
    "KnownL3MplsThreeLabel", \
    "KnownL3MplsFourLabel", \
    "KnownL3MplsMoreThanFourLabel", \
    "UnknownL4", \
    "InnerUnknownL4", \
    "UdpUnknownL5", \
    "InnerUdpUnknownL5", \
    "UdpGpeGeneve", \
    "UdpBfd", \
    "InnerUdpBfd", \
    "UdpVxlan", \
    "Udp1588", \
    "TcpUnknownL5", \
    "InnerTcpUnknownL5", \
    "SctpUnknownL5", \
    "InnerSctpUnknownL5", \
    "GreWithoutKey", \
    "GreWithKey", \
    "GreWithoutChecksumRouting", \
    "L2GreWithoutChecksumRouting", \
    "L2GreWithoutRouting", \
    "AchNonIp", \
    "UdpINT", \
    "TcpUnknownL5WithIpExtnHdr", \
    "L3GreUnknownPayload", \
    "GreWithKeyRouting", \
    "L2GreWithKeyRouting", \
    "InnerUdp1588", \
    "TcpINT", \
    "KnownL3FcoeUnknownRctl", \
    "HiGigPpd0", \
    "HiGigPpd0EHType0", \
    "HiGigPpd0EHType1", \
    "HiGigPpd0EHType2", \
    "HiGigPpd2", \
    "HiGigPpd2EHType0", \
    "HiGigPpd2EHType1", \
    "HiGigPpd2EHType2", \
    "GpeIOAM", \
    "KnownMplsMcast", \
    "LoopbackHdrType0", \
    "LoopbackHdrType1", \
    "L3Ipv4Fragmented", \
    "L3Ipv4FragmentedWithOptions", \
    "L3Ipv4WithoutOptions", \
    "L3Ipv4WithOptions", \
    "L3Ipv6", \
    "L2", \
    "L2Untagged", \
    "L2OuterVlanTag", \
    "L2InnerVlanTag", \
    "L2DoubleVlanTag", \
    "L2GbpTag", \
    "L2OuterVlanWithGbpTag", \
    "L2InnerVlanWithGbpTag", \
    "L2DoubleVlanWithGbpTag", \
    "L2Vntag", \
    "L2OuterVlanWithVntag", \
    "L2InnerVlanWithVntag", \
    "L2DoubleVlanWithVntag", \
    "L2Etag", \
    "L2OuterVlanEtag", \
    "L2InnerVlanEtag", \
    "L2DoubleVlanEtag", \
    "InnerL3Ipv4", \
    "InnerL3Ipv4Fragmented", \
    "InnerL3Ipv6", \
    "InnerL2Untagged", \
    "InnerL2OuterVlanTag", \
    "InnerL2InnerVlanTag", \
    "InnerL2DoubleVlanTag", \
    "InnerL2GbpTag", \
    "InnerL2OuterVlanWithGbpTag", \
    "InnerL2InnerVlanWithGbpTag", \
    "InnerL2DoubleVlanWithGbpTag", \
    "UnknownL3CustomEtherType1", \
    "UnknownL3CustomEtherType2", \
    "UnknownL3CustomIpProtocol1", \
    "UnknownL3CustomIpProtocol2", \
    "UnknownL3CustomUdpDstPort1", \
    "UnknownL3CustomUdpDstPort2", \
    "InnerUnknownL3CustomEtherType1", \
    "InnerUnknownL3CustomEtherType2", \
    "InnerUnknownL3CustomIpProtocol1", \
    "InnerUnknownL3CustomIpProtocol2", \
    "InnerUnknownL3CustomUdpDstPort1", \
    "InnerUnknownL3CustomUdpDstPort2", \
    "UdpProbeBasedINT", \
    "MacsecDecrypt", \
    "GpeIOAMEdgeToEdge", \
    "UdpVxlanWithoutExtnHdr", \
    "Udp1588WithoutExtnHdr", \
    "UdpBfdWithoutExtnHdr", \
    "UdpProbeBasedINTWithoutExtnHdr", \
    "UdpINTWithoutExtnHdr", \
    "InnerTcpUnknownL5WithoutExtnHdr", \
    "UdpUnknownL5WithoutExtnHdr"  \
}

/* UDF tunnel term flow types. */
typedef enum bcm_udf_tunnel_term_flow_type_e {
    bcmUdfTunnelTermFlowTypeMimWithIpPayload = 0, /* MiM with IP Payload. */
    bcmUdfTunnelTermFlowTypeMimWithoutIpPayload = 1, /* MiM without IP Payload. */
    bcmUdfTunnelTermFlowTypeL2MplsWithIpPayload = 2, /* L2 MPLS with IP Payload. */
    bcmUdfTunnelTermFlowTypeL2MplsWithoutIpPayload = 3, /* L2 MPLS without IP Payload. */
    bcmUdfTunnelTermFlowTypeL2GreWithIpPayload = 4, /* L2 GRE with IP Payload. */
    bcmUdfTunnelTermFlowTypeL2GreWithoutIpPayload = 5, /* L2 GRE without IP Payload. */
    bcmUdfTunnelTermFlowTypeVxlanWithIpPayload = 6, /* VxLAN with IP Payload. */
    bcmUdfTunnelTermFlowTypeVxlanWithoutIpPayload = 7, /* VxLAN without IP Payload. */
    bcmUdfTunnelTermFlowTypeL3Mpls = 8, /* L3 MPLS. */
    bcmUdfTunnelTermFlowTypeL3Tunnel = 9, /* L3 Tunnel. */
    bcmUdfTunnelTermFlowTypeL3GpeGeneve = 10, /* L3 Gpe Geneve. */
    bcmUdfTunnelTermFlowTypeLastCount = 11 /* Unused. Always last in the list */
} bcm_udf_tunnel_term_flow_type_t;

#define BCM_UDF_TUNNEL_TERM_FLOW_TYPE \
{ \
    "MimWithIpPayload", \
    "MimWithoutIpPayload", \
    "L2MplsWithIpPayload", \
    "L2MplsWithoutIpPayload", \
    "L2GreWithIpPayload", \
    "L2GreWithoutIpPayload", \
    "VxlanWithIpPayload", \
    "VxlanWithoutIpPayload", \
    "L3Mpls", \
    "L3Tunnel", \
    "L3GpeGeneve"  \
}

/* UDF Chunk Information Structure. */
typedef struct bcm_udf_chunk_info_s {
    int offset;                         /* Relative offset in bits (Starts from
                                           base offset of given abstract packet
                                           format) in the packet */
    uint32 width;                       /* width of data in bits to extract */
    uint32 chunk_bmap;                  /* Chunk bitmap (Each bit in the bitmap
                                           represents 1 chunk (2 bytes) */
    bcm_udf_abstract_pkt_format_t abstract_pkt_format; /* Abstract Packet Format (one of the
                                           format from
                                           'bcm_udf_abstract_pkt_format_t') */
} bcm_udf_chunk_info_t;

/* Pkt Base offset. */
typedef enum bcm_udf_pkt_base_offset_e {
    bcmUdfPktBaseOffsetStartOfOuterL2 = 0, /* Base offset from the start of Outer
                                           L2 Header. */
    bcmUdfPktBaseOffsetStartOfOuterLlc = 1, /* Base offset from the start of Outer
                                           LLC Header. */
    bcmUdfPktBaseOffsetStartOfTunnel = 2, /* Base offset from the start of Tunnel
                                           Header. */
    bcmUdfPktBaseOffsetStartOfOuterL3 = 3, /* Base offset from the start of Outer
                                           L3 Header. */
    bcmUdfPktBaseOffsetStartOfOuterL4 = 4, /* Base offset from the start of Outer
                                           L4 Header. */
    bcmUdfPktBaseOffsetStartOfOuterL5 = 5, /* Base offset from the start of Outer
                                           L5 Header. */
    bcmUdfPktBaseOffsetStartOfInnerL2 = 6, /* Base offset from the start of Inner
                                           L2 Header. */
    bcmUdfPktBaseOffsetStartOfInnerLlc = 7, /* Base offset from the start of Inner
                                           LLC Header. */
    bcmUdfPktBaseOffsetStartOfInnerL3 = 8, /* Base offset from the start of Inner
                                           L3 Header. */
    bcmUdfPktBaseOffsetStartOfInnerL4 = 9, /* Base offset from the start of Inner
                                           L4 Header. */
    bcmUdfPktBaseOffsetStartOfInnerL5 = 10, /* Base offset from the start of Inner
                                           L5 Header. */
    bcmUdfPktBaseOffsetStartOfSystemHeader = 11, /* Base offset from the start of system
                                           header (HiGig or Loopback). */
    bcmUdfPktBaseOffsetStartOf14bytesAfterOuterL2 = 12, /* Base offset from the start of 14
                                           bytes after Outer L2 Header. (For
                                           example: In-case of L2 Single tagged
                                           packet, it is start of 802.1p
                                           priority field after TPID.) */
    bcmUdfPktBaseOffsetStartOf12bytesAfterInnerL2 = 13, /* Base offset from the start of 12
                                           bytes after Outer L2 Header. */
    bcmUdfPktBaseOffsetStartOfGpe = 14, /* Base offset from the start of GPE
                                           Header. */
    bcmUdfPktBaseOffsetLastCount = 15   /* Unused. Always last in the list */
} bcm_udf_pkt_base_offset_t;

#define BCM_UDF_PKT_BASE_OFFSET \
{ \
    "StartOfOuterL2", \
    "StartOfOuterLlc", \
    "StartOfTunnel", \
    "StartOfOuterL3", \
    "StartOfOuterL4", \
    "StartOfOuterL5", \
    "StartOfInnerL2", \
    "StartOfInnerLlc", \
    "StartOfInnerL3", \
    "StartOfInnerL4", \
    "StartOfInnerL5", \
    "StartOfSystemHeader", \
    "StartOf14bytesAfterOuterL2", \
    "StartOf12bytesAfterInnerL2", \
    "StartOfGpe"  \
}

/* UDF Abstract Packet Format Information Structure. */
typedef struct bcm_udf_abstract_pkt_format_info_s {
    bcm_udf_pkt_base_offset_t base_offset; /* Relative offset of
                                           'bcmUdfPktBaseOffsetXX' type (from
                                           'bcm_udf_pkt_base_offset_t') */
    uint32 num_chunks_max;              /* Maximum number of chunks supported by
                                           the abstract packet format */
    uint32 chunk_bmap_used;             /* Bitmap of Chunks already used by the
                                           abstract packet format */
    uint32 unavail_chunk_bmap;          /* Bitmap of Chunks unavailable/reserved */
} bcm_udf_abstract_pkt_format_info_t;

#define BCM_UDF_CHUNKS_MAX      32         

/* Array of bits to define the UDF chunk bitmap. */
typedef struct bcm_udf_cbmp_s {
    SHR_BITDCL w[_SHR_BITDCLSIZE(BCM_UDF_CHUNKS_MAX)]; 
} bcm_udf_cbmp_t;

/* UDF Chunk bitmap INIT operation */
#define BCM_UDF_CBMP_CHUNK_INIT(cbmp)  \
    sal_memset(&(cbmp), 0x0, sizeof(bcm_udf_cbmp_t)) 

/* UDF Chunk Add operation */
#define BCM_UDF_CBMP_CHUNK_ADD(cbmp, chunk)  SHR_BITSET(((cbmp).w), (chunk)) 

/* UDF Chunk Remove operation */
#define BCM_UDF_CBMP_CHUNK_REMOVE(cbmp, chunk)  SHR_BITCLR(((cbmp).w), (chunk)) 

/* UDF Chunk Test operation */
#define BCM_UDF_CBMP_CHUNK_TEST(cbmp, chunk)  SHR_BITGET(((cbmp).w), (chunk)) 

/* UDF Multi Chunk Information Structure. */
typedef struct bcm_udf_multi_chunk_info_s {
    int offset;                         /* Relative offset in bits (Starts from
                                           base offset of given abstract packet
                                           format) in the packet */
    uint32 width;                       /* width of data in bits to extract */
    bcm_udf_cbmp_t one_byte_chunk_bmap; /* Chunk bitmap (Each bit in the bitmap
                                           represents 1 chunk of 1 byte each */
    bcm_udf_cbmp_t two_byte_chunk_bmap; /* Chunk bitmap (Each bit in the bitmap
                                           represents 1 chunk of 2 bytes each */
    bcm_udf_cbmp_t four_byte_chunk_bmap; /* Chunk bitmap (Each bit in the bitmap
                                           represents 1 chunk of 4 bytes each */
    bcm_udf_abstract_pkt_format_t abstract_pkt_format; /* Abstract Packet Format (one of the
                                           format from
                                           'bcm_udf_abstract_pkt_format_t') */
} bcm_udf_multi_chunk_info_t;

/* UDF Multi Abstract Packet Format Information Structure. */
typedef struct bcm_udf_multi_abstract_pkt_format_info_s {
    bcm_udf_pkt_base_offset_t base_offset; /* Relative offset of
                                           'bcmUdfPktBaseOffsetXX' type (from
                                           'bcm_udf_pkt_base_offset_t') */
    uint32 num_chunks_max;              /* Maximum number of chunks supported by
                                           the abstract packet format */
    bcm_udf_cbmp_t chunk_4b_bmap_avail; /* Available 4-byte Chunk bitmap. */
    bcm_udf_cbmp_t chunk_2b_bmap_avail; /* Available 2-byte Chunk bitmap. */
    bcm_udf_cbmp_t chunk_1b_bmap_avail; /* Available 1-byte Chunk bitmap. */
} bcm_udf_multi_abstract_pkt_format_info_t;

#endif /* __BCM_UDF_H__ */
